# A series of python functions for parsing
# JSON data packed into a string

#################
# Parsing Driver
#################
# expand_annotations(Dict)

####################
# Parsing Functions
####################
# build_tree_from_string(string)
# is_simple_token(string, string)
# is_parametrized_token(string, string)
# extract_tag(string, string)
# extract_parameters(string)
# split_on_major_delimiter(string, string)

# For more information, see the header comments on each


def expand_annotations(source_dictionary):
    """Takes a partially extracted JSON tree generated by C++ and parses
    the annotations fields, expanding them into python dictionary
    trees.
    @param source_dictionary - The dictionary containing the annotation
                               fields to expand.
    """
    for annotation_key, annotation_value in source_dictionary['annotations'].iteritems():
        for attribute_name, attribute_value in annotation_value.iteritems():
            # The tree returned might be collapsible into a list
            # or a string. Check and perform the appropriate adjustment.
            result = build_tree_from_string(attribute_value)
            if is_simple_string(result):
                source_dictionary['annotations'][annotation_key][
                    attribute_name] = convert_key_to_string(result)
            elif is_list(result):
                source_dictionary['annotations'][annotation_key][
                    attribute_name] = convert_keys_to_list(result)
            else:
                source_dictionary['annotations'][annotation_key][
                    attribute_name] = result


def build_tree_from_string(formatted_data):
    """ Recursively builds a dictionary tree out of a string using the
    following rules:
    Parameter lists: Token(Arguments...)  become Dictionary entries:
                     Token:Arguments...
    Any parameter list that is a string or list of strings gets saved as
    such.
    This will always return a dictionary, even if given a simple string
    or a list of strings. The is_simple_string and is_list detection
    functions and convert_key_to_string and convert_keys_to_list functions
    can be used to process the results further if necessary.
    @param formatted_data - A string of data formatted by the
                            AZCodeGenerator C++ Parser
    @return A dictionary containing all the data parsed out of the
            incoming string.
    """
    result = {}

    # The AZCodeGen system can produce empty parameter lists
    # early detection will prevent python crashes
    if formatted_data is None:
        return None

    # remove whitespace
    formatted_data.strip()

    # The AZCodeGen system can produce empty strings as parameter lists
    # Early detection will speed up execution
    if not formatted_data:
        return None

    # AZCodeGen allows spaces, commas, and tabs to be used as major
    # delimiters
    # in lists
    delimiters = " ,\t"

    # terminal case (Simple Token)
    if is_simple_token(formatted_data, delimiters):
        result[formatted_data] = None
    # recursive case (New Parameter)
    elif is_parametrized_token(formatted_data, delimiters):
        tag = extract_tag(formatted_data, delimiters)
        dictionary_result = build_tree_from_string(
            extract_parameters(formatted_data))
        # Determine if we can flatten the parameter list into a string
        # or a list of strings
        if is_simple_string(dictionary_result):
            result[tag] = convert_key_to_string(dictionary_result)
        elif is_list(dictionary_result):
            result[tag] = convert_keys_to_list(dictionary_result)
        else:
            result[tag] = dictionary_result
    # There are multiple tokens At This Level.
    # Separate and parse them individually.
    else:
        for arg in split_on_major_delimiter(formatted_data, delimiters):
            result.update(build_tree_from_string(arg))

    return result


def string_detector( string_data ):
    """Generator that runs through a string and tracks weather or not it's
    inside inside a set of double-quotes at any given point in time.
    Full support for escaped quotes is supported.
    Example:
    string_detector("This \"is in a \\\"String\\\"\" right?")
                           ^^^^^^^^^^^^^^^^^^^^^^^^
    will return true only when iterating over the characters flagged
    by the ^s.
    @param string_data - A string to iterate over
    @return A bool, false while the string being iterated over is
            outside of matching quotes, true while inside.
    """
    escaped = False
    in_string = False

    for c in string_data:
        # Handle Strings
        if not escaped and c == '\"':
            if in_string:
                in_string = False
            else:
                in_string = True

        # Handle Escape Sequences
        if c == '\\' and escaped == False:
            escaped = True
        else:
            escaped = False

        yield in_string


def is_simple_token(string_data, delimiters):
    """Returns true if the given string doesn't contain any delimiters or
    parenthesis that aren't contained inside a quotation. This is the
    terminal case when parsing a JSON string.
    @param string_data - The string we're going to check
    @param delimiters - A string containing all the delimiters that could
                        separate valid tokens.
    @return True if string_data is a simple token, False otherwise
    """
    valid = True
    index = 0

    string_checker = string_detector(string_data)

    for c in string_data:
        in_string_flag = next(string_checker)

        # Handle Parenthesis
        if not in_string_flag and c == '(':
            # Any opening parenthesis outside of strings invalid tokens
            valid = False

        # Find Separators
        if not in_string_flag:
            if delimiters.find(c) != -1:
                # Major Delimiters Invalidate Tokens
                valid = False

        # increment our index
        index += 1

        if not valid:
            break

    return valid


def is_parametrized_token(string_data, delimiters):
    """return True if the string is a single token with data in parenthesis
    For Example:
      "Token(\"Arguments\")"           will return True
      "Token(\"Arguments\"),Token"     will return False
    Used to detect tokens with arguments
    make sure to trim excess whitespace from the beginning and end
    of the source string
    @param string_data - The string to check for a parametrized token
    @param delimiters - A string containing all the delimiters that could
                        separate valid tokens.
    @return True if string_data contains a parametrized token, false
            otherwise
    """
    parenthesis_depth = 0
    parenthesis_found = False
    zero_count = 0
    last_close = 0
    valid = True
    index = 0

    string_checker = string_detector(string_data)

    for c in string_data:
        in_string_flag = next(string_checker)

        # Handle Parenthesis
        if not in_string_flag and c == '(':
            # a parametrized token requires a tag before parenthesis
            if index == 0:
                valid = False
                break
            parenthesis_depth += 1
            parenthesis_found = True

        # Handle closing parenthesis
        if not in_string_flag and c == ')':
            parenthesis_depth -= 1
            if parenthesis_depth == 0:
                zero_count += 1
                last_close = index + 1

        # Find Delimiters
        if not in_string_flag and parenthesis_depth == 0:
            # Major Delimiters Invalidate all Tokens
            if delimiters.find(c) != -1:
                valid = False
                break

        # increment our index
        index += 1

    return valid and parenthesis_found and zero_count == 1 and last_close == index


def extract_tag(string_data, delimiters):
    """Extract and return a tag associate with a parameter
    list in a string.
    For example:
    "Token(Parameter)" would return "Token"
    Note: The incoming string must be validated by is_parametrized_token
    @param string_data - A string containing a parametrized token to
                         extract the tag from
    @param delimiters - A string containing all the delimiters that
                        could separate valid tokens.
    @return A string containing the tag associate with the parametrized
            token
    """
    found = False
    index = 0

    string_checker = string_detector(string_data)

    for c in string_data:
        in_string_flag = next(string_checker)

        # Handle Parenthesis
        if not in_string_flag and c == '(':
            found = True
            break

        # Major delimiters can't be found before the parameter
        # tag is discovered.
        if not in_string_flag:
            if delimiters.find(c) != -1:
                break

        # increment our index
        index += 1

    if found:
        return string_data[:index]
    else:
        return "null"


def extract_parameters(string_data):
    """4xtract and return the parameters contained in parenthesis
    of a parametrized JSON entry in a string.
    For example:
    "Token(Parameter)" would return "Parameter"
    Note: The incoming string must be validated by is_parametrized_token
    @param string_data - The incoming string to extract parameters from
    @return A string containing the parameter string of the input token
    """
    parenthesis_depth = 0
    open_index = 0
    close_index = 0
    index = 0

    string_checker = string_detector(string_data)

    for c in string_data:
        in_string_flag = next(string_checker)

        # Handle Parenthesis
        if not in_string_flag and c == '(':
            parenthesis_depth += 1
            if parenthesis_depth == 1:
                open_index = index + 1
        if not in_string_flag and c == ')':
            parenthesis_depth -= 1
            if parenthesis_depth == 0:
                close_index = index

        # increment our index
        index += 1

    if open_index > close_index:
        return "null"
    else:
        return string_data[open_index:close_index]


def split_on_major_delimiter(string_data, delimiters):
    """Split a string using the given separator but only
    when the separator isn't contained in a string or
    a set of valid parenthesis
    @param string_data - the string of delimited arguments
    @param delimiters - The delimiters to split the string on
    @return a list of strings containing the individual elements
            of the input string.
    """
    parenthesis_depth = 0
    start = 0
    index = 0
    result = []

    string_checker = string_detector( string_data )

    for c in string_data:

        in_string_flag = next(string_checker)

        # Handle Parenthesis
        if not in_string_flag and c == '(':
            parenthesis_depth += 1
        if not in_string_flag and c == ')':
            parenthesis_depth -= 1

        # Find Separators
        if not in_string_flag and parenthesis_depth == 0:
            if delimiters.find(c) != -1:
                # Allow consecutive major delimiters
                if index != start:
                    # Save the token
                    token = string_data[start:index]
                    result.append(string_data[start:index])
                # Set the start of the next token to the next character
                start = index + 1

        # increment our index
        index += 1

    # handle the last token
    if index != start:
        result.append(string_data[start:])

    return result


############################################################
# Helper Functions
############################################################

def is_simple_string(test_dictionary):
    """These take dictionaries and determine if they can be converted to
    various types simpler strings or lists of strings or perform
    the actual conversions


    Detect if a dictionary can be converted to a string
    @param test_dictionary - A dictionary to test
    @return False if the incoming dictionary is empty, has multiple
            key/value pairs, or has any values at all that
            aren't the type None. True if the dictionary has
            one key/value pair and the value is of type None.
    """
    if test_dictionary is not None:
        none_flag = True
        for value in test_dictionary.values():
            if value is not None:
                none_flag = False
                break
        return none_flag and len(test_dictionary) == 1
    return False


def is_list(test_dictionary):
    """Detect if a dictionary can be converted into
    a list of strings
    @param test_dictionary - The dictionary to test
    @return False if the incoming dictionary is empty, has only a single
            key/value pair, or has any values at all that aren't
            the None type. True if the dictionary has multiple
            key/value pairs and the values are all of type None.
    """
    if test_dictionary is not None:
        none_flag = True
        for value in test_dictionary.values():
            if value is not None:
                none_flag = False
                break
        return none_flag and len(test_dictionary) > 1
    return False


def convert_keys_to_list(source_dictionary):
    """Convert all the keys in a dictionary into a list of strings
    make sure to verify that the incoming dictionary can
    be converted to a list using the above is_list() function
    @param source_dictionary - A dictionary to convert
    @return A list of strings derived from the keys of the
            incoming dictionary.
    """
    result = []
    for key in source_dictionary.keys():
        result.append(str(key))
    return result


def convert_key_to_string(source_dictionary):
    """Convert the first key found in a Dictionary to a string
    make sure to verify that the incoming dictionary
    can be converted to a string using the
    is_simple_string() above
    @param source_dictionary - The dictionary containing the string
    @return A string derived from first key found in the
            incoming dictionary
    """
    return source_dictionary.keys()[0]
